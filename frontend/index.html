<!doctype html>
<html lang="el">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hackthon-UOI-2025</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&family=Space+Grotesk:wght@500;600;700&display=swap"
    rel="stylesheet"
  />
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="bg-grid"></div>

  <header class="topbar">
    <div class="brand">
      <svg viewBox="0 0 24 24" aria-hidden="true" class="logo">
        <path d="M12 2v20M2 12h20M7 7h10v10H7z"></path>
        <circle cx="12" cy="12" r="9"></circle>
      </svg>
      <div class="brand-text">
        <span class="brand-title">Hackathon UOI 2025</span>
        <span class="brand-sub">404: Disease Not Found</span>
      </div>
      <span class="badge">beta</span>
    </div>
    <nav class="top-links" aria-label="ŒíŒ±œÉŒπŒ∫œå ŒºŒµŒΩŒøœç">
      <a class="top-link" href="#upload">Upload</a>
      <a class="top-link" href="#gradcam">X-Ray With Heatmap</a>
      <a class="top-link" href="#llm">AI Explanation</a>
      <a class="top-link" href="#results">Probabilities</a>
    </nav>
    <button id="themeBtn" class="icon-btn" aria-label="ŒïŒΩŒ±ŒªŒªŒ±Œ≥ŒÆ Œ∏Œ≠ŒºŒ±œÑŒøœÇ">
      <span class="sun">‚òÄÔ∏è</span><span class="moon">üåô</span>
    </button>
  </header>

  <main class="container">
    <!-- HERO -->
    <section class="hero">
      <div class="hero-copy">
        <h1>VisionX</h1>
        <p>
          AI Pre-Diagnostics Tool
        </p>
      </div>
    </section>

    <!-- 1. UPLOAD -->
    <section class="pane upload" id="upload">
      <div class="pane-header">
        <h2>Upload X-ray Images</h2>
        <p class="muted">Select single or multiple chest radiographs for intelligent analysis and risk classification.</p>
      </div>

      <!-- Mode selector -->
      <div class="mode-selector">
        <label>
          <input type="radio" name="uploadMode" value="single" checked id="singleMode" />
          <span>Single Image Analysis</span>
        </label>
        <label>
          <input type="radio" name="uploadMode" value="batch" id="batchMode" />
          <span>Batch Risk Classification</span>
        </label>
      </div>

      <div id="dropzone" class="dropzone" tabindex="0" aria-label="Œ†ŒµœÅŒπŒøœáŒÆ ŒºŒµœÑŒ±œÜŒøœÅŒ¨œÇ Œ±œÅœáŒµŒØŒøœÖ">
        <input id="fileInput" type="file" accept="image/*" hidden />
        <div class="drop-inner">
          <div class="drop-icon">‚¨Ü</div>
          <div>
            <button id="browseBtn" class="btn">üìÅ Select Image</button>
            <span class="hint">or drag & drop here</span>
          </div>
        </div>
        <img id="preview" class="preview hidden" alt="Œ†œÅŒøŒµœÄŒπœÉŒ∫œåœÄŒ∑œÉŒ∑ ŒµŒπŒ∫œåŒΩŒ±œÇ" />
        <div id="batchPreview" class="batch-preview hidden"></div>
      </div>

      <div class="actions">
        <button id="predictBtn" class="btn primary" disabled>Analyze</button>
        <button id="clearBtn" class="btn ghost" disabled>Clear</button>
      </div>
      <div id="progress" class="progress hidden" role="status" aria-live="polite">
        <span class="spinner"></span> Processing...
      </div>
    </section>

    <!-- 2 & 3: GRAD-CAM AND RESULTS (Side by Side) -->
    <div class="two-column-layout">
      <!-- 2. WHAT THE MODEL SEES (GRAD-CAM) -->
      <section class="pane gradcam" id="gradcam">
        <div class="pane-header">
          <h2> AI Visual Attention</h2>
          <p class="muted">Grad-CAM highlights diagnostic regions.</p>
        </div>

        <div id="gradcamViewer" class="cam-viewer hidden" aria-live="polite">
          <div class="cam-header">
            <div>
              <h3>Grad-CAM Focus</h3>
              <p id="gradcamTarget" class="muted"></p>
            </div>
            <button id="heatmapToggle" class="btn toggle-btn">Heatmap: ON</button>
          </div>

          <div class="cam-main">
            <!-- Plain X-ray (no heatmap) -->
            <div id="camPlain" class="cam-image-wrap hidden">
              <img id="plainXray" alt="X-ray without heatmap" />
            </div>

            <!-- X-ray + heatmap stack (aligned) -->
            <div id="camWithHeatmap" class="cam-image-wrap">
              <img id="gradcamBase" alt="X-ray / Grad-CAM base" />
              <img id="gradcamOverlay" alt="Grad-CAM heatmap overlay" />
            </div>

            <label class="slider-label" for="heatmapSlider">
              <span>Heatmap opacity</span>
              <input
                type="range"
                id="heatmapSlider"
                min="0"
                max="100"
                value="60"
              />
            </label>
          </div>
        </div>

        <p class="disclaimer">‚ö†Ô∏è <strong>Important:</strong> Research demonstration only.</p>
      </section>

      <!-- 3. PROBABILITIES -->
      <section class="pane results" id="results">
        <div class="pane-header">
          <h2> Prediction Results</h2>
          <p class="muted">AI probability scores for pathologies.</p>
        </div>

        <div id="result" class="result">
          <div class="empty">No prediction has been made yet.</div>
        </div>

        <!-- All probabilities, instantly visible (no top-3-only, no details/summary) -->
        <div id="bars" class="bars"></div>
        
        <!-- Risk Level Display -->
        <div id="riskLevel" class="risk-level-display" style="display: none;">
          <div class="risk-level-label">Clinical Risk Level</div>
          <div class="risk-level-value">
            <span class="risk-level-icon"></span>
            <span class="risk-level-text"></span>
          </div>
          <div class="risk-level-description"></div>
        </div>
      </section>
    </div>

    <!-- BATCH RESULTS -->
    <section class="pane batch-results hidden" id="batchResults">
      <div class="pane-header">
        <h2> Batch Risk Classification Results</h2>
        <p class="muted">Automated triage: Images intelligently organized by clinical risk level based on AI predictions.</p>
      </div>

      <div id="batchSummary" class="batch-summary"></div>
      
      <div id="batchOutput" class="batch-output">
        <div class="risk-category">
          <h3 class="risk-high">üî¥ High Risk</h3>
          <div id="highRisk" class="risk-images"></div>
        </div>
        
        <div class="risk-category">
          <h3 class="risk-medium">üü° Medium Risk</h3>
          <div id="mediumRisk" class="risk-images"></div>
        </div>
        
        <div class="risk-category">
          <h3 class="risk-low">üü¢ Low Risk</h3>
          <div id="lowRisk" class="risk-images"></div>
        </div>
      </div>
    </section>

    <!-- 4. LLM EXPLANATION -->
    <section class="pane llm" id="llm">
      <div class="pane-header">
        <h2> AI Clinical Interpretation</h2>
        <p class="muted">
          Advanced language model provides detailed explanation of findings, clinical significance, and potential diagnoses.
        </p>
      </div>

      <div class="llm-controls">
        <button id="llmBtn" class="btn primary" disabled> Generate Explanation</button>
        <button id="extractBtn" class="btn ghost" disabled>üìÑ Extract Report</button>
        <span id="llmStatus" class="muted hidden">‚è≥ Contacting AI model‚Ä¶</span>
      </div>

      <div id="llmOutput" class="llm-output empty">
        Run a prediction first, then ask the AI for an explanation.
      </div>
    </section>
  </main>

  <footer class="footer">
    <span>¬© 2025 Hackathon UOI ¬∑ AI Pre-Diagnostics Tool ¬∑ Research & Education Use Only</span>
  </footer>

  <script>
    // ---- API endpoints ----
    const API_URL = "http://localhost:8080/predict";
    const BATCH_API_URL = "http://localhost:8080/predict_batch";
    const LLM_API_URL = "http://localhost:8080/llm_explain";

    // ---- DOM elements ----
    const dropzone = document.getElementById("dropzone");
    const fileInput = document.getElementById("fileInput");
    const browseBtn = document.getElementById("browseBtn");
    const predictBtn = document.getElementById("predictBtn");
    const clearBtn = document.getElementById("clearBtn");
    const preview = document.getElementById("preview");
    const batchPreview = document.getElementById("batchPreview");
    const progress = document.getElementById("progress");
    const singleMode = document.getElementById("singleMode");
    const batchMode = document.getElementById("batchMode");

    const result = document.getElementById("result");
    const bars = document.getElementById("bars");
    const riskLevel = document.getElementById("riskLevel");

    const gradcamViewer = document.getElementById("gradcamViewer");
    const gradcamTarget = document.getElementById("gradcamTarget");
    const gradcamBase = document.getElementById("gradcamBase");
    const gradcamOverlay = document.getElementById("gradcamOverlay");
    const plainXray = document.getElementById("plainXray");
    const camPlain = document.getElementById("camPlain");
    const camWithHeatmap = document.getElementById("camWithHeatmap");
    const heatmapToggle = document.getElementById("heatmapToggle");
    const heatmapSlider = document.getElementById("heatmapSlider");

    const llmBtn = document.getElementById("llmBtn");
    const extractBtn = document.getElementById("extractBtn");
    const llmStatus = document.getElementById("llmStatus");
    const llmOutput = document.getElementById("llmOutput");

    const themeBtn = document.getElementById("themeBtn");

    const batchResults = document.getElementById("batchResults");
    const batchSummary = document.getElementById("batchSummary");
    const highRisk = document.getElementById("highRisk");
    const mediumRisk = document.getElementById("mediumRisk");
    const lowRisk = document.getElementById("lowRisk");

    let currentFile = null;
    let currentFiles = [];  // For batch mode
    let uploadMode = "single";  // "single" or "batch"
    let lastPrediction = null;   // { pred_class, probs }
    let lastExplanation = "";    // AI description
    let heatmapEnabled = true;

    // ---- Theme ----
    const setTheme = (mode) => {
      document.documentElement.dataset.theme = mode;
      localStorage.setItem("ui-theme", mode);
    };
    themeBtn.addEventListener("click", () => {
      const next = document.documentElement.dataset.theme === "light" ? "dark" : "light";
      setTheme(next);
    });
    setTheme(localStorage.getItem("ui-theme") || "dark");

    // ---- Upload Mode ----
    singleMode.addEventListener("change", (e) => {
      if (e.target.checked) {
        uploadMode = "single";
        fileInput.removeAttribute("multiple");
        // Show sections 2, 3, 4 when switching to single mode
        document.getElementById("gradcam").classList.remove("hidden");
        document.getElementById("results").classList.remove("hidden");
        document.getElementById("llm").classList.remove("hidden");
        batchResults.classList.add("hidden");
        resetUI();
      }
    });
    batchMode.addEventListener("change", (e) => {
      if (e.target.checked) {
        uploadMode = "batch";
        fileInput.setAttribute("multiple", "");
        // Hide sections 2, 3, 4 when switching to batch mode
        document.getElementById("gradcam").classList.add("hidden");
        document.getElementById("results").classList.add("hidden");
        document.getElementById("llm").classList.add("hidden");
        resetUI();
      }
    });

    // ---- Helpers ----
    function enableActions(enabled) {
      predictBtn.disabled = !enabled;
      clearBtn.disabled = !enabled;
    }

    function triggerDownload(url, filename) {
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }
    
    // Risk Level Classification Function
    function classifyRiskLevel(topLabel) {
      const riskCategories = {
        high: {
          conditions: ["Consolidation", "Pneumothorax", "Edema", "Pneumonia", "Lung Lesion"],
          icon: "üî¥",
          text: "High Risk",
          description: "Requires immediate medical attention"
        },
        medium: {
          conditions: ["Atelectasis", "Effusion", "Cardiomegaly", "Enlarged Cardiomediastinum", "Lung Opacity"],
          icon: "üü°",
          text: "Medium Risk",
          description: "Requires monitoring and follow-up"
        },
        low: {
          conditions: ["Fracture"],
          icon: "üü¢",
          text: "Low Risk",
          description: "Structural issue requiring standard care"
        }
      };
      
      // Check which category the condition belongs to
      for (const [level, data] of Object.entries(riskCategories)) {
        if (data.conditions.includes(topLabel)) {
          return {
            level: level,
            icon: data.icon,
            text: data.text,
            description: data.description
          };
        }
      }
      
      // Default to medium risk if not found
      return {
        level: "medium",
        icon: "üü°",
        text: "Medium Risk",
        description: "Requires clinical evaluation"
      };
    }

    function resetUI() {
      currentFile = null;
      currentFiles = [];
      lastPrediction = null;
      lastExplanation = "";
      heatmapEnabled = true;

      // upload
      preview.src = "";
      preview.classList.add("hidden");
      batchPreview.classList.add("hidden");
      batchPreview.innerHTML = "";
      dropzone.classList.remove("has-image");

      enableActions(false);
      progress.classList.add("hidden");

      // results
      result.innerHTML = `<div class="empty">No prediction has been made yet.</div>`;
      bars.innerHTML = "";
      riskLevel.style.display = "none";

      // batch results
      batchResults.classList.add("hidden");
      batchSummary.innerHTML = "";
      highRisk.innerHTML = "";
      mediumRisk.innerHTML = "";
      lowRisk.innerHTML = "";

      // gradcam
      gradcamViewer.classList.add("hidden");
      gradcamTarget.textContent = "";
      gradcamBase.src = "";
      gradcamOverlay.src = "";
      plainXray.src = "";
      camPlain.classList.add("hidden");
      camWithHeatmap.classList.remove("hidden");
      heatmapToggle.textContent = "Heatmap: ON";
      if (heatmapSlider) {
        heatmapSlider.value = 60;
        gradcamOverlay.style.opacity = 0.6;
      }

      // llm
      llmBtn.disabled = true;
      extractBtn.disabled = true;
      llmStatus.classList.add("hidden");
      llmOutput.classList.add("empty");
      llmOutput.textContent = "Run a prediction first, then ask the AI for an explanation.";
    }

    function setPreview(file) {
      const url = URL.createObjectURL(file);
      preview.src = url;
      // Do not revoke: we reuse for plainXray
      preview.classList.remove("hidden");
      dropzone.classList.add("has-image");
      enableActions(true);
    }

    function pickFile(file) {
      if (!file || !file.type.startsWith("image/")) {
        alert("Please select an image file.");
        return;
      }
      currentFile = file;
      setPreview(file);
    }

    function pickFiles(files) {
      if (!files || files.length === 0) {
        alert("Please select at least one image file.");
        return;
      }
      
      // Filter only image files
      const imageFiles = Array.from(files).filter(f => f.type.startsWith("image/"));
      if (imageFiles.length === 0) {
        alert("Please select valid image files.");
        return;
      }

      currentFiles = imageFiles;
      
      // Show batch preview
      preview.classList.add("hidden");
      batchPreview.classList.remove("hidden");
      batchPreview.innerHTML = `<p style="text-align:center; padding: 1rem;">${imageFiles.length} images selected</p>`;
      dropzone.classList.add("has-image");
      enableActions(true);
    }

    // ---- Drag & Drop ----
    ["dragenter", "dragover"].forEach(ev =>
      dropzone.addEventListener(ev, e => {
        e.preventDefault();
        dropzone.classList.add("drag");
      })
    );
    ["dragleave", "drop"].forEach(ev =>
      dropzone.addEventListener(ev, e => {
        e.preventDefault();
        dropzone.classList.remove("drag");
      })
    );
    dropzone.addEventListener("drop", e => {
      if (uploadMode === "batch") {
        pickFiles(e.dataTransfer.files);
      } else {
        const file = e.dataTransfer.files?.[0];
        pickFile(file);
      }
    });

    // ---- Click / Browse ----
    browseBtn.addEventListener("click", () => fileInput.click());
    dropzone.addEventListener("click", () => {
      if (!dropzone.classList.contains("has-image")) fileInput.click();
    });
    fileInput.addEventListener("change", e => {
      if (uploadMode === "batch") {
        pickFiles(e.target.files);
      } else {
        pickFile(e.target.files?.[0]);
      }
    });

    // ---- Paste (Ctrl/‚åò+V) ----
    window.addEventListener("paste", e => {
      const file = Array.from(e.clipboardData.files || [])[0];
      if (file) pickFile(file);
    });

    // ---- Clear ----
    clearBtn.addEventListener("click", resetUI);

    // ---- Heatmap slider ----
    if (heatmapSlider && gradcamOverlay) {
      heatmapSlider.addEventListener("input", () => {
        const value = Number(heatmapSlider.value) || 0;
        gradcamOverlay.style.opacity = value / 100;
      });
    }

    // ---- Heatmap toggle button ----
    heatmapToggle.addEventListener("click", () => {
      heatmapEnabled = !heatmapEnabled;
      if (heatmapEnabled) {
        camPlain.classList.add("hidden");
        camWithHeatmap.classList.remove("hidden");
        heatmapToggle.textContent = "Heatmap: ON";
      } else {
        camWithHeatmap.classList.add("hidden");
        camPlain.classList.remove("hidden");
        heatmapToggle.textContent = "Heatmap: OFF";
      }
    });

    // ---- Predict ----
    predictBtn.addEventListener("click", async () => {
      if (uploadMode === "batch") {
        await handleBatchPredict();
      } else {
        await handleSinglePredict();
      }
    });

    async function handleSinglePredict() {
      if (!currentFile) return;

      progress.classList.remove("hidden");
      
      // Show sections 2, 3, 4 in single mode
      document.getElementById("gradcam").classList.remove("hidden");
      document.getElementById("results").classList.remove("hidden");
      document.getElementById("llm").classList.remove("hidden");
      
      result.innerHTML = "";
      bars.innerHTML = "";
      riskLevel.style.display = "none";
      batchResults.classList.add("hidden");
      gradcamViewer.classList.add("hidden");
      gradcamBase.src = "";
      gradcamOverlay.src = "";
      plainXray.src = "";
      gradcamTarget.textContent = "";

      lastPrediction = null;
      lastExplanation = "";
      llmBtn.disabled = true;
      extractBtn.disabled = true;
      llmStatus.classList.add("hidden");
      llmOutput.classList.add("empty");
      llmOutput.textContent = "Run a prediction first, then ask the AI for an explanation.";

      const form = new FormData();
      form.append("file", currentFile);

      try {
        const resp = await fetch(API_URL, { method: "POST", body: form });

        if (!resp.ok) {
          const err = await resp.json().catch(() => ({ detail: "Œ£œÜŒ¨ŒªŒºŒ± server" }));
          throw new Error(err.detail || "Œ£œÜŒ¨ŒªŒºŒ± server");
        }

        const data = await resp.json();
        
        // Get top prediction only
        const topLabel = Array.isArray(data.pred_class) ? data.pred_class[0] : data.pred_class;
        const topProb = data.probs[topLabel];
        
        // Store only top 1 prediction for LLM explanation
        lastPrediction = {
          pred_class: [topLabel],  // Only top 1
          probs: data.probs
        };
        
        result.innerHTML = `
          <div class="pred">
            <div class="pred-label">Top Prediction: ${topLabel ?? "‚Äî"}</div>
          </div>
        `;

        // ---- Show ONLY top 1 probability ----
        bars.innerHTML = "";
        if (topProb !== undefined) {
          const pct = (topProb * 100).toFixed(1);
          const row = document.createElement("div");
          row.className = "bar-row";
          row.innerHTML = `
            <div class="bar-label">${topLabel}</div>
            <div class="bar">
              <div class="bar-fill" style="width:${pct}%"></div>
            </div>
            <div class="bar-val">${pct}%</div>
          `;
          bars.appendChild(row);
        }
        
        // ---- Risk Level Classification ----
        const riskClassification = classifyRiskLevel(topLabel);
        riskLevel.className = `risk-level-display ${riskClassification.level}`;
        riskLevel.style.display = 'block';
        
        const riskIcon = riskLevel.querySelector('.risk-level-icon');
        const riskText = riskLevel.querySelector('.risk-level-text');
        const riskDesc = riskLevel.querySelector('.risk-level-description');
        
        riskIcon.textContent = riskClassification.icon;
        riskText.textContent = riskClassification.text;
        riskDesc.textContent = riskClassification.description;

        // ---- Grad-CAM ----
        if (data.gradcam_overlay && data.gradcam_heatmap && data.processed_image) {

          // Base: overlay image from backend (X-ray + heatmap 224x224)
          gradcamBase.src = `data:image/png;base64,${data.gradcam_overlay}`;
          // Overlay: heatmap-only
          gradcamOverlay.src = `data:image/png;base64,${data.gradcam_heatmap}`;
          // Plain X-ray: processed image from backend
          plainXray.src = `data:image/png;base64,${data.processed_image}`;

          if (heatmapSlider) {
            const value = Number(heatmapSlider.value) || 60;
            gradcamOverlay.style.opacity = value / 100;
          } else {
            gradcamOverlay.style.opacity = 0.6;
          }

          gradcamTarget.textContent = data.gradcam_target
            ? `Highlighted class: ${data.gradcam_target}`
            : "";

          heatmapEnabled = true;
          camPlain.classList.add("hidden");
          camWithHeatmap.classList.remove("hidden");
          heatmapToggle.textContent = "Heatmap: ON";

          gradcamViewer.classList.remove("hidden");
        }

        // Enable LLM
        llmBtn.disabled = false;
        llmOutput.classList.remove("empty");
        llmOutput.textContent = "Click 'Generate explanation' to get an AI summary.";
      } catch (e) {
        result.innerHTML = `<div class="error">‚ùå ${e.message || e}</div>`;
        gradcamViewer.classList.add("hidden");
        llmBtn.disabled = true;
        extractBtn.disabled = true;
      } finally {
        progress.classList.add("hidden");
      }
    }

    async function handleBatchPredict() {
      if (!currentFiles || currentFiles.length === 0) return;

      progress.classList.remove("hidden");
      
      // Hide sections 2, 3, 4 in batch mode
      gradcamViewer.classList.add("hidden");
      document.getElementById("gradcam").classList.add("hidden");
      document.getElementById("results").classList.add("hidden");
      document.getElementById("llm").classList.add("hidden");
      
      result.innerHTML = "";
      bars.innerHTML = "";
      batchResults.classList.add("hidden");
      highRisk.innerHTML = "";
      mediumRisk.innerHTML = "";
      lowRisk.innerHTML = "";
      batchSummary.innerHTML = "";

      const form = new FormData();
      currentFiles.forEach(file => {
        form.append("files", file);
      });

      try {
        const resp = await fetch(BATCH_API_URL, { method: "POST", body: form });

        if (!resp.ok) {
          const err = await resp.json().catch(() => ({ detail: "Server error" }));
          throw new Error(err.detail || "Server error");
        }

        const data = await resp.json();
        
        // Display summary with cards
        const summary = data.summary || {};
        batchSummary.innerHTML = `
          <div class="batch-summary-grid">
            <div class="summary-card high">
              <div class="label">üî¥ High Risk</div>
              <div class="value">${summary.High || 0}</div>
            </div>
            <div class="summary-card medium">
              <div class="label">üü° Medium Risk</div>
              <div class="value">${summary.Medium || 0}</div>
            </div>
            <div class="summary-card low">
              <div class="label">üü¢ Low Risk</div>
              <div class="value">${summary.Low || 0}</div>
            </div>
            <div class="summary-card total">
              <div class="label">üìä Total Images</div>
              <div class="value">${currentFiles.length}</div>
            </div>
          </div>
          <p style="text-align: center; color: var(--muted); font-size: 13px;">
            üìÅ Images saved to: <strong>${data.output_directory || 'classified_images'}</strong>
          </p>
        `;

        // Display images grouped by risk
        const results = data.results || [];
        results.forEach((item, idx) => {
          if (item.error) return; // Skip errors for now

          const card = document.createElement("div");
          card.className = "image-card";
          
          // Show only top prediction (no top 3)
          card.innerHTML = `
            <div class="filename">${item.filename}</div>
            <div class="prediction">
              <strong>Top Prediction:</strong> ${item.top_label} (${(item.top_probability * 100).toFixed(1)}%)
            </div>
          `;

          // Add to appropriate risk section
          if (item.risk_level === "High") {
            highRisk.appendChild(card);
          } else if (item.risk_level === "Medium") {
            mediumRisk.appendChild(card);
          } else if (item.risk_level === "Low") {
            lowRisk.appendChild(card);
          }
        });

        // Add empty messages if needed
        if (highRisk.children.length === 0) {
          highRisk.innerHTML = '<p style="text-align:center; color: var(--text-muted); padding: 1rem;">No images in this category</p>';
        }
        if (mediumRisk.children.length === 0) {
          mediumRisk.innerHTML = '<p style="text-align:center; color: var(--text-muted); padding: 1rem;">No images in this category</p>';
        }
        if (lowRisk.children.length === 0) {
          lowRisk.innerHTML = '<p style="text-align:center; color: var(--text-muted); padding: 1rem;">No images in this category</p>';
        }

        batchResults.classList.remove("hidden");

      } catch (e) {
        result.innerHTML = `<div class="error">‚ùå ${e.message || e}</div>`;
      } finally {
        progress.classList.add("hidden");
      }
    }

    // ---- LLM explanation formatting ----
    function formatLLMOutput(text) {
      // Parse the LLM output and format it with sections
      const sections = [];
      
      // Try to parse structured output
      const analysisMatch = text.match(/ANALYSIS:\s*([\s\S]*?)(?=SUMMARY:|$)/i);
      const summaryMatch = text.match(/SUMMARY:\s*([\s\S]*?)(?=LIMITATIONS|$)/i);
      const limitationsMatch = text.match(/LIMITATIONS.*?:\s*([\s\S]*?)$/i);
      
      let html = '';
      
      if (analysisMatch || summaryMatch || limitationsMatch) {
        // Structured output detected
        if (analysisMatch) {
          const content = analysisMatch[1].trim();
          html += `
            <div class="llm-section analysis">
              <div class="llm-section-title">üìã Clinical Analysis</div>
              <div class="llm-section-content">${formatContent(content)}</div>
            </div>
          `;
        }
        
        if (summaryMatch) {
          const content = summaryMatch[1].trim();
          html += `
            <div class="llm-section summary">
              <div class="llm-section-title">üìù Summary</div>
              <div class="llm-section-content">${formatContent(content)}</div>
            </div>
          `;
        }
        
        if (limitationsMatch) {
          const content = limitationsMatch[1].trim();
          html += `
            <div class="llm-section limitations">
              <div class="llm-section-title">‚ö†Ô∏è Important Disclaimers</div>
              <div class="llm-section-content">${formatContent(content)}</div>
            </div>
          `;
        }
        
        return html;
      } else {
        // Unstructured output - just format nicely
        return `<div class="llm-section-content">${formatContent(text)}</div>`;
      }
    }
    
    function formatContent(text) {
      // Convert bullet points to proper list
      const lines = text.split('\n').map(line => line.trim()).filter(line => line);
      const hasBullets = lines.some(line => line.startsWith('-') || line.startsWith('‚Ä¢'));
      
      if (hasBullets) {
        const listItems = [];
        let currentParagraph = [];
        
        for (const line of lines) {
          if (line.startsWith('-') || line.startsWith('‚Ä¢')) {
            if (currentParagraph.length > 0) {
              listItems.push(`<p>${currentParagraph.join(' ')}</p>`);
              currentParagraph = [];
            }
            listItems.push(line.replace(/^[-‚Ä¢]\s*/, ''));
          } else {
            currentParagraph.push(line);
          }
        }
        
        if (currentParagraph.length > 0) {
          listItems.push(`<p>${currentParagraph.join(' ')}</p>`);
        }
        
        // Separate paragraphs from list items
        const paragraphs = listItems.filter(item => item.startsWith('<p>'));
        const bullets = listItems.filter(item => !item.startsWith('<p>'));
        
        let html = paragraphs.join('');
        if (bullets.length > 0) {
          html += '<ul>' + bullets.map(item => `<li>${item}</li>`).join('') + '</ul>';
        }
        
        return html;
      } else {
        // Just paragraphs
        return lines.map(line => `<p>${line}</p>`).join('');
      }
    }
    
    function buildFallbackExplanation(pred) {
      if (!pred || !pred.probs) {
        return "No probabilities available to generate an explanation.";
      }
      const entries = Object.entries(pred.probs).sort((a, b) => b[1] - a[1]);
      const top = entries[0]; // Only top 1

      if (top) {
        const [name, p] = top;
        const pct = (p * 100).toFixed(1);
        return (
          `Based on the model's output, the most likely finding is: ${name} (~${pct}%). ` +
          "This description is heuristic and should not be used for clinical decisions."
        );
      }

      return "No predictions available.";
    }

    llmBtn.addEventListener("click", async () => {
      if (!lastPrediction) return;

      llmBtn.disabled = true;
      extractBtn.disabled = true;
      llmStatus.classList.remove("hidden");
      llmOutput.classList.remove("empty");
      llmOutput.innerHTML = "";

      try {
        const resp = await fetch(LLM_API_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(lastPrediction),
        });

        if (!resp.ok) {
          throw new Error("LLM server error");
        }

        const data = await resp.json();
        const explanation = data.explanation || "The LLM did not return an explanation. Please try again.";
        
        // Format the explanation with sections
        llmOutput.innerHTML = formatLLMOutput(explanation);
        lastExplanation = explanation; // Store raw text for export
      } catch (e) {
        const fallback = buildFallbackExplanation(lastPrediction);
        llmOutput.innerHTML = formatLLMOutput(fallback);
        lastExplanation = fallback;
      } finally {
        llmStatus.classList.add("hidden");
        llmBtn.disabled = false;
        extractBtn.disabled = !lastExplanation;
      }
    });

    // ---- Extract report ----
    extractBtn.addEventListener("click", () => {
      if (!lastPrediction || !lastPrediction.probs) {
        alert("No prediction available. Please run a prediction first.");
        return;
      }
      if (!lastExplanation) {
        alert("No AI explanation available. Please generate the explanation first.");
        return;
      }

      const baseName = prompt(
        "Enter a base name for the exported files (e.g., patient_001):"
      );
      if (!baseName) {
        return; // user cancelled
      }

      // 1) Save plain X-ray image
      const xraySrc = plainXray.src || preview.src;
      if (xraySrc) {
        triggerDownload(xraySrc, `${baseName}_xray.png`);
      } else {
        alert("X-ray image not found in the viewer.");
      }

      // 2) Save X-ray + heatmap image
      if (gradcamBase.src) {
        triggerDownload(gradcamBase.src, `${baseName}_xray_heatmap.png`);
      } else {
        alert("X-ray + heatmap image not found.");
      }

      // 3) Save symptoms + explanation as CSV (Excel-readable)
      const probs = lastPrediction.probs || {};
      const entries = Object.entries(probs).sort((a, b) => b[1] - a[1]);

      const lines = [];
      lines.push("Finding,Probability");
      entries.forEach(([name, p]) => {
        const pct = (p * 100).toFixed(1);
        lines.push(`"${name.replace(/"/g, '""')}",${pct}`);
      });

      lines.push("");
      const safeExplanation = lastExplanation.replace(/"/g, '""');
      lines.push(`"Explanation","${safeExplanation}"`);

      const csvContent = lines.join("\n");
      const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      triggerDownload(url, `${baseName}_report.csv`);
      URL.revokeObjectURL(url);
    });

    // ---- Init ----
    resetUI();
  </script>
</body>
</html>
